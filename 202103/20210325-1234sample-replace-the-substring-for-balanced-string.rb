def balanced_string(s)
  # hash 储存各字符出现的次数
  h = Hash.new(0)
  len = s.length
  
  s.each_char {|ch| h[ch] += 1}
  
  # 默认最短子串长度为字符串长度
  res = len

  # 左指针指向第 0 个元素之前
  l = 0
  
  # 右指针从第 0 个元素之前向最后一个元素之后遍历
  for r in (0..len)
    
    # 当左指针不越界、且移除左右指针之间的子串后的字符串各字符出现的次数均不大于理应出现的次数 (len / 4)时，左指针继续遍历
    # 当且仅当各字符出现次数均小于等于 len / 4 时，删掉子串后可以平衡各字符出现次数
    # - 充分条件：各字符均小于等于 len / 4 时，还需要多少个字符 X，就将子串中多少个字符改成 X
    # - 必要条件：若字符 X 在剩余字符串中出现次数大于 len / 4，无论如何修改子串，X 在总字符串中出现次数都不可能小于等于 len / 4，此时必有另一个字符出现的总次数小于 len / 4
    while l < len && h.all?{|_, v| v <= len / 4}
      res = [res,  r - l].min # 满足条件时，更新结果最小值
      h[s[l]] += 1 # 左指针指向的字符回到剩余字符串，该字符出现次数 +1
      l += 1 # 左指针右移
    end
    
    h[s[r]] -= 1 if r < len # 右指针右移，右指针原来指向的字符从剩余字符串删除（最后一次循环时右指针已经在最右字符右边，因此无需也不可能更改计数）
  end
  
  res
end4